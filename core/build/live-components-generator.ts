// ðŸš€ FluxStack Live Components - Auto Registration Generator
// Automatically generates component registration during build time

import { existsSync, readdirSync, writeFileSync, unlinkSync, readFileSync } from 'fs'
import { join, extname, basename } from 'path'
import { buildLogger } from '../utils/build-logger'

export interface ComponentInfo {
  fileName: string
  className: string
  componentName: string
  filePath: string
}

export class LiveComponentsGenerator {
  private componentsPath: string
  private registrationFilePath: string
  private backupFilePath: string
  private entryPointPath: string
  private entryPointBackupPath: string
  private readonly importLine = 'import "@core/server/live/auto-generated-components"'

  constructor() {
    // Scan components from app/ directory (user code)
    this.componentsPath = join(process.cwd(), 'app', 'server', 'live')

    // Generate registration file in core/ directory (framework code - protected from user modifications)
    this.registrationFilePath = join(process.cwd(), 'core', 'server', 'live', 'auto-generated-components.ts')
    this.backupFilePath = join(process.cwd(), 'core', 'server', 'live', 'auto-generated-components.backup.ts')

    // Entry point for import injection
    this.entryPointPath = join(process.cwd(), 'app', 'server', 'index.ts')
    this.entryPointBackupPath = join(process.cwd(), 'app', 'server', 'index.ts.backup')
  }

  /**
   * Scan the live components directory and discover all components
   */
  discoverComponents(): ComponentInfo[] {
    if (!existsSync(this.componentsPath)) {
      return []
    }

    const components: ComponentInfo[] = []
    const files = readdirSync(this.componentsPath)

    for (const file of files) {
      // Skip non-TypeScript files, backup files, and the registration file itself
      if (!file.endsWith('.ts') || 
          file === 'register-components.ts' || 
          file.includes('.backup.') ||
          file.includes('.bak')) {
        continue
      }

      const filePath = join(this.componentsPath, file)
      const fileName = basename(file, extname(file))
      
      try {
        // Read file content to extract class name
        const content = readFileSync(filePath, 'utf-8')
        
        // Look for class exports that extend LiveComponent
        const classMatches = content.match(/export\s+class\s+(\w+)\s+extends\s+LiveComponent/g)
        
        if (classMatches && classMatches.length > 0) {
          for (const match of classMatches) {
            const classNameMatch = match.match(/class\s+(\w+)/)
            if (classNameMatch) {
              const className = classNameMatch[1]
              const componentName = className.replace(/Component$/, '')
              
              components.push({
                fileName,
                className,
                componentName,
                // Path relative to core/server/live/ where the generated file will be
                filePath: `@app/server/live/${fileName}`
              })

              buildLogger.step(`Discovered component: ${className} â†’ ${componentName}`)
            }
          }
        }
      } catch (error) {
        // Silently skip files that can't be analyzed
      }
    }

    return components
  }

  /**
   * Generate the registration file with all discovered components
   */
  generateRegistrationFile(components: ComponentInfo[]): void {
    // Backup existing file if it exists
    if (existsSync(this.registrationFilePath)) {
      const existingContent = readFileSync(this.registrationFilePath, 'utf-8')
      writeFileSync(this.backupFilePath, existingContent)
    }

    // Generate imports
    const imports = components
      .map(comp => `import { ${comp.className} } from "${comp.filePath}"`)
      .join('\n')

    // Generate registrations
    const registrations = components
      .map(comp => `    componentRegistry.registerComponentClass('${comp.componentName}', ${comp.className})`)
      .join('\n')

    // Generate file content
    const fileContent = `// ðŸ”¥ Auto-generated Live Components Registration
// This file is automatically generated during build time - DO NOT EDIT MANUALLY
// Generated at: ${new Date().toISOString()}

${imports}
import { componentRegistry } from "@core/server/live/ComponentRegistry"

// Register all components statically for production bundle
function registerAllComponents() {
  try {
    // Auto-generated component registrations
${registrations}
    
    console.log('ðŸ“ Live components registered successfully! (${components.length} components)')
  } catch (error) {
    console.warn('âš ï¸ Error registering components:', error)
  }
}

// Auto-register components
registerAllComponents()

// Export all components to ensure they're included in the bundle
export { 
${components.map(comp => `  ${comp.className}`).join(',\n')}
}
`

    writeFileSync(this.registrationFilePath, fileContent)
    buildLogger.success(`Generated registration for ${components.length} components`)
  }

  /**
   * Restore the original registration file from backup
   */
  restoreOriginalFile(): void {
    if (existsSync(this.backupFilePath)) {
      const backupContent = readFileSync(this.backupFilePath, 'utf-8')
      writeFileSync(this.registrationFilePath, backupContent)
      unlinkSync(this.backupFilePath)
    }
  }

  /**
   * Inject the auto-generated components import into the entry point
   */
  injectImportIntoEntryPoint(): void {
    if (!existsSync(this.entryPointPath)) {
      buildLogger.warn('Entry point not found, skipping import injection')
      return
    }

    const content = readFileSync(this.entryPointPath, 'utf-8')

    // Check if import already exists
    if (content.includes(this.importLine)) {
      return // Already injected
    }

    // Backup original file
    writeFileSync(this.entryPointBackupPath, content)

    // Find the best place to inject (after other imports)
    const lines = content.split('\n')
    let lastImportIndex = -1

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim()
      if (line.startsWith('import ') || line.startsWith('import{')) {
        lastImportIndex = i
      }
    }

    // Inject after the last import
    if (lastImportIndex >= 0) {
      lines.splice(lastImportIndex + 1, 0, this.importLine)
    } else {
      // No imports found, add at the beginning
      lines.unshift(this.importLine)
    }

    writeFileSync(this.entryPointPath, lines.join('\n'))
    buildLogger.step('Injected auto-generated components import into entry point')
  }

  /**
   * Remove the injected import and restore original entry point
   */
  removeInjectedImport(): void {
    if (existsSync(this.entryPointBackupPath)) {
      const backupContent = readFileSync(this.entryPointBackupPath, 'utf-8')
      writeFileSync(this.entryPointPath, backupContent)
      unlinkSync(this.entryPointBackupPath)
      buildLogger.step('Restored original entry point')
    }
  }

  /**
   * Check if the current registration file is auto-generated
   */
  isAutoGenerated(): boolean {
    if (!existsSync(this.registrationFilePath)) {
      return false
    }

    const content = readFileSync(this.registrationFilePath, 'utf-8')
    return content.includes('// ðŸ”¥ Auto-generated Live Components Registration')
  }

  /**
   * Pre-build hook: Generate registration file
   */
  async preBuild(): Promise<ComponentInfo[]> {
    buildLogger.section('Live Components Discovery', 'ðŸš€')

    const components = this.discoverComponents()

    if (components.length === 0) {
      buildLogger.warn('No Live Components found')
      return []
    }

    // Create table of discovered components
    const componentData = components.map(c => ({
      component: c.componentName,
      className: c.className,
      file: c.fileName + '.ts'
    }))

    buildLogger.table(
      [
        { header: 'Component', key: 'component', width: 20, align: 'left', color: 'cyan' },
        { header: 'Class Name', key: 'className', width: 25, align: 'left' },
        { header: 'File', key: 'file', width: 20, align: 'left', color: 'gray' }
      ],
      componentData
    )

    this.generateRegistrationFile(components)

    // Inject import into entry point for build
    this.injectImportIntoEntryPoint()

    return components
  }

  /**
   * Post-build hook: Clean up backup file and restore entry point
   * Note: Since the generated file is now in core/, we always keep it (it's bundled into production)
   */
  async postBuild(keepGenerated: boolean = true): Promise<void> {
    buildLogger.step('Cleaning up Live Components registration...')

    // Always keep the generated file in core/ (it gets bundled)
    // Just remove the backup
    if (existsSync(this.backupFilePath)) {
      unlinkSync(this.backupFilePath)
      buildLogger.step('Removed backup file')
    }

    // Restore original entry point (remove injected import)
    this.removeInjectedImport()
  }

  /**
   * Development mode: Check if registration needs update
   */
  needsUpdate(): boolean {
    if (!this.isAutoGenerated()) {
      return false // Manual file, don't touch
    }

    const components = this.discoverComponents()
    const currentContent = readFileSync(this.registrationFilePath, 'utf-8')
    
    // Check if all discovered components are in the current file
    for (const comp of components) {
      if (!currentContent.includes(`'${comp.componentName}', ${comp.className}`)) {
        return true
      }
    }

    return false
  }

  /**
   * Development mode: Update registration if needed
   */
  updateIfNeeded(): void {
    if (this.needsUpdate()) {
      buildLogger.info('Live Components changed, updating registration...')
      const components = this.discoverComponents()
      this.generateRegistrationFile(components)
    }
  }
}

// Export singleton instance
export const liveComponentsGenerator = new LiveComponentsGenerator()