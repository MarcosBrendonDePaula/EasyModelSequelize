// ðŸš€ FluxStack Plugins - Auto Registration Generator
// Automatically generates plugin registration during build time

import { existsSync, readdirSync, writeFileSync, unlinkSync, readFileSync, statSync } from 'fs'
import { join, extname, basename } from 'path'
import { buildLogger } from '../utils/build-logger'

export interface PluginInfo {
  pluginDir: string
  pluginName: string
  entryFile: string
  relativePath: string
  type: 'external' | 'built-in'
}

export class FluxPluginsGenerator {
  private pluginsPath: string
  private builtInPluginsPath: string
  private registrationFilePath: string
  private backupFilePath: string

  constructor() {
    this.pluginsPath = join(process.cwd(), 'plugins')
    this.builtInPluginsPath = join(process.cwd(), 'core', 'plugins', 'built-in')
    this.registrationFilePath = join(process.cwd(), 'core', 'plugins', 'auto-registry.ts')
    this.backupFilePath = join(process.cwd(), 'core', 'plugins', 'auto-registry.backup.ts')
  }

  /**
   * Scan plugin directories and discover external plugins only
   * Built-in plugins are handled by the core system
   */
  discoverPlugins(): PluginInfo[] {
    const plugins: PluginInfo[] = []

    // Discover external plugins only
    if (existsSync(this.pluginsPath)) {
      const externalPlugins = this.discoverPluginsInDirectory(this.pluginsPath, 'external')
      plugins.push(...externalPlugins)
    }

    // Note: Built-in plugins are automatically loaded by core system
    // No need to include them in auto-generation

    return plugins
  }

  /**
   * Discover plugins in a specific directory
   */
  private discoverPluginsInDirectory(directory: string, type: 'external' | 'built-in'): PluginInfo[] {
    const plugins: PluginInfo[] = []

    try {
      const entries = readdirSync(directory)

      for (const entry of entries) {
        const pluginDir = join(directory, entry)
        
        // Skip files, only process directories
        if (!statSync(pluginDir).isDirectory()) {
          continue
        }

        // Look for plugin entry point
        const entryFile = this.findPluginEntryFile(pluginDir)
        if (entryFile) {
          const relativePath = type === 'external' 
            ? `../../plugins/${entry}`
            : `./built-in/${entry}`

          plugins.push({
            pluginDir,
            pluginName: entry,
            entryFile,
            relativePath,
            type
          })

          buildLogger.step(`Discovered ${type} plugin: ${entry} (${entryFile})`)
        } else {
          buildLogger.warn(`Plugin '${entry}' has no valid entry point`)
        }
      }
    } catch (error) {
      // Silently skip directories that can't be scanned
    }

    return plugins
  }

  /**
   * Find the main plugin entry file
   */
  private findPluginEntryFile(pluginDir: string): string | null {
    const possibleFiles = [
      'index.ts',
      'index',
      'plugin.ts',
      'plugin',
      'src/index.ts',
      'src/index',
      'dist/index'
    ]

    for (const file of possibleFiles) {
      const filePath = join(pluginDir, file)
      if (existsSync(filePath)) {
        return basename(file)
      }
    }

    return null
  }

  /**
   * Generate the registration file with all discovered plugins
   */
  generateRegistrationFile(plugins: PluginInfo[]): void {
    // Backup existing file if it exists
    if (existsSync(this.registrationFilePath)) {
      const existingContent = readFileSync(this.registrationFilePath, 'utf-8')
      writeFileSync(this.backupFilePath, existingContent)
    }

    // All discovered plugins are external (built-in are handled by core)
    const externalPlugins = plugins

    // Generate imports
    const imports = plugins
      .map(plugin => {
        const importName = this.getImportName(plugin.pluginName)
        const importPath = plugin.entryFile === 'index.ts' || plugin.entryFile === 'index'
          ? plugin.relativePath
          : `${plugin.relativePath}/${plugin.entryFile.replace(/\.(ts|js)$/, '')}`
        return `import ${importName} from "${importPath}"`
      })
      .join('\n')

    // Generate plugin array
    const pluginsList = plugins
      .map(plugin => {
        const importName = this.getImportName(plugin.pluginName)
        return `  ${importName}`
      })
      .join(',\n')

    // Generate file content
    const fileContent = `// ðŸ”¥ Auto-generated FluxStack External Plugins Registry
// This file is automatically generated during build time - DO NOT EDIT MANUALLY
// Built-in plugins are handled by the core system automatically
// Generated at: ${new Date().toISOString()}

import type { Plugin } from './types'

${imports}

// Auto-discovered external plugins array
export const discoveredPlugins: Plugin[] = [
${pluginsList}
]

// All discovered plugins are external (built-in handled by core)
export const externalPlugins = discoveredPlugins

// Plugin registration function
export async function registerDiscoveredPlugins(registry: any): Promise<void> {
  if (discoveredPlugins.length === 0) {
    console.log('ðŸ“¦ No external plugins to register')
    return
  }
  
  console.log(\`ðŸ“¦ Registering \${discoveredPlugins.length} auto-discovered external plugins...\`)
  
  let registered = 0
  let failed = 0
  
  for (const plugin of discoveredPlugins) {
    try {
      await registry.register(plugin)
      registered++
      console.log(\`âœ… Registered external plugin: \${plugin.name}\`)
    } catch (error) {
      failed++
      console.error(\`âŒ Failed to register external plugin \${plugin.name}:\`, error)
    }
  }
  
  console.log(\`ðŸ“Š External plugin registration complete: \${registered} registered, \${failed} failed\`)
}

// Export plugin names for easy access
export const pluginNames = discoveredPlugins.map(p => p.name)

console.log('ðŸ” Auto-discovered ${plugins.length} external plugins' + (pluginNames.length > 0 ? ': ' + pluginNames.join(', ') : ''))
`

    writeFileSync(this.registrationFilePath, fileContent)
    buildLogger.success(`Generated registry for ${plugins.length} plugins`)
  }

  /**
   * Generate a valid import name from plugin name
   */
  private getImportName(pluginName: string): string {
    // Convert kebab-case to PascalCase for import names
    return pluginName
      .split('-')
      .map(part => part.charAt(0).toUpperCase() + part.slice(1))
      .join('') + 'Plugin'
  }

  /**
   * Restore the original registration file from backup
   */
  restoreOriginalFile(): void {
    if (existsSync(this.backupFilePath)) {
      const backupContent = readFileSync(this.backupFilePath, 'utf-8')
      writeFileSync(this.registrationFilePath, backupContent)
      unlinkSync(this.backupFilePath)
    } else {
      // If no backup exists, remove the generated file
      if (existsSync(this.registrationFilePath)) {
        unlinkSync(this.registrationFilePath)
      }
    }
  }

  /**
   * Check if the current registration file is auto-generated
   */
  isAutoGenerated(): boolean {
    if (!existsSync(this.registrationFilePath)) {
      return false
    }

    const content = readFileSync(this.registrationFilePath, 'utf-8')
    return content.includes('// ðŸ”¥ Auto-generated FluxStack Plugins Registry')
  }

  /**
   * Pre-build hook: Generate registration file
   */
  async preBuild(): Promise<PluginInfo[]> {
    buildLogger.section('FluxStack Plugins Discovery', 'ðŸ”Œ')

    const plugins = this.discoverPlugins()

    if (plugins.length === 0) {
      buildLogger.warn('No FluxStack Plugins found')
      return []
    }

    // Create table of discovered plugins
    const pluginData = plugins.map(p => ({
      plugin: p.pluginName,
      type: p.type,
      entry: p.entryFile
    }))

    buildLogger.table(
      [
        { header: 'Plugin', key: 'plugin', width: 25, align: 'left', color: 'cyan' },
        { header: 'Type', key: 'type', width: 12, align: 'left', color: 'yellow' },
        { header: 'Entry Point', key: 'entry', width: 20, align: 'left', color: 'gray' }
      ],
      pluginData
    )

    this.generateRegistrationFile(plugins)

    return plugins
  }

  /**
   * Post-build hook: Clean up generated file (optional)
   */
  async postBuild(keepGenerated: boolean = false): Promise<void> {
    buildLogger.step('Cleaning up FluxStack Plugins registry...')

    if (keepGenerated) {
      // Remove backup since we're keeping the generated version
      if (existsSync(this.backupFilePath)) {
        unlinkSync(this.backupFilePath)
      }
    } else {
      this.restoreOriginalFile()
    }
  }

  /**
   * Development mode: Check if registration needs update
   */
  needsUpdate(): boolean {
    if (!this.isAutoGenerated()) {
      return false // No auto-generated file, don't touch manual setup
    }

    const plugins = this.discoverPlugins()
    const currentContent = readFileSync(this.registrationFilePath, 'utf-8')
    
    // Check if all discovered plugins are in the current file
    for (const plugin of plugins) {
      const importName = this.getImportName(plugin.pluginName)
      if (!currentContent.includes(importName)) {
        return true
      }
    }

    return false
  }

  /**
   * Development mode: Update registration if needed
   */
  updateIfNeeded(): void {
    if (this.needsUpdate()) {
      buildLogger.info('FluxStack Plugins changed, updating registry...')
      const plugins = this.discoverPlugins()
      this.generateRegistrationFile(plugins)
    }
  }
}

// Export singleton instance
export const fluxPluginsGenerator = new FluxPluginsGenerator()